<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="Description of support files" href="support.html" /><link rel="prev" title="&amp;Process" href="control/process.html" />

    <!-- Generated with Sphinx 6.1.3 and Furo 2022.12.07 -->
        <title>Operators to compute new fields - fieldextra v13_0_0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">fieldextra v13_0_0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">fieldextra v13_0_0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Program usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="products.html">Supported products and data representations</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="control/intro.html">Control file</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="control/runSpec.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">&amp;RunSpecification</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="control/globRes.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">&amp;GlobalResource</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="control/globSet.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">&amp;GlobalSettings</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="control/netcdf.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">&amp;NetCDFImport</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="control/inspectSpec.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">&amp;InspectSpecification</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="control/modelSpec.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">&amp;ModelSpecification</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="control/process.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">&amp;Process</span></code></a></li>
</ul>
</li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Operators to compute new fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">Description of support files</a></li>
<li class="toctree-l1"><a class="reference internal" href="output.html">Description of output format</a></li>
<li class="toctree-l1"><a class="reference internal" href="grib1.html">Description of some GRIB1 conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="grib2.html">Description of GRIB2 local use</a></li>
<li class="toctree-l1"><a class="reference internal" href="meta.html">Handling of meta-information</a></li>
<li class="toctree-l1"><a class="reference internal" href="aboutOpsTags.html">About operators and tags</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">Description of tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="lexicon.html">Lexicon</a></li>
<li class="toctree-l1"><a class="reference internal" href="summary.html">Summary of namelist objects and their usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">:nl:nl:`Test`</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="operators-to-compute-new-fields">
<span id="chapter-5"></span><h1>Operators to compute new fields<a class="headerlink" href="#operators-to-compute-new-fields" title="Permalink to this heading">#</a></h1>
<p>There are three options to derive new meteorological fields within the
same class of products:</p>
<ol class="arabic simple">
<li><p>use an operator which is univoquely defined by the name of the new
field to compute (e.g. RELHUM). These operators are triggered by
using the name of the field in the corresponding processing iteration
(e.g. tmp1_field=’RELHUM’). All associated parent fields must be
present in the previous iteration, and the name of the main parent
must be defined in the active dictionary.
Such operators belong to the n to 1 transformation category. The list
of currently implemented operators is available in 5.1 below, and in
README.user.locale.
When multiple operators are available for the same field, the operator
used by fieldextra depends on the main parent declared in the active
dictionary or set through use_tag.</p></li>
<li><p>use an operator directly defined by its name, by setting appropriately
the value of use_operator. The list of parent fields must be explicitely
declared by setting the value of use_tag, the first element of the list
being the main parent. All associated parent fields must be present in
the previous iteration. The name of the new field is declared as usual
(e.g. tmp1_field=…) but must correspond to the name coded in the
associated procedure.
Such operators belong to the n to 1 transformation category. The list
of currently implemented operators is available in 5.2 below, and in
README.user.locale.</p></li>
<li><p>For more complex and specific transformations, use a postprocessing
operator by setting appropriately the value of out_postproc_module.
This option is only available after the last processing iteration,
and all associated parent fields must be present in the last
iteration.
Such operators belong to the n to n transformation category. The list
of currently implemented operators is available in 5.3 below, and in
README.user.locale.</p></li>
</ol>
<p>The implementation of new operators is described in README.developer. Worth
noting here is the separation between operators of common interest,
implemented in fxtr_operator_generic and described below, and operators of
local interest only, implemented in the local version of fxtr_operator_specific
and described in README.user.locale.</p>
<section id="meteorological-operators">
<h2>Meteorological operators<a class="headerlink" href="#meteorological-operators" title="Permalink to this heading">#</a></h2>
<p>(Activated by short name of field and dictionary content)</p>
<dl class="simple">
<dt>field     operator description</dt><dd><p>list of parent fields (first in the list is the main parent)</p>
</dd>
</dl>
<section id="constant-fields-produced-in-incore">
<h3>constant fields (produced in INCORE)<a class="headerlink" href="#constant-fields-produced-in-incore" title="Permalink to this heading">#</a></h3>
<dl class="simple">
<dt>RLAT      latitude in true geog. system [deg. N];</dt><dd><dl class="simple">
<dt>RLAT = f(gds)</dt><dd><p>at least one input field required in INCORE</p>
</dd>
</dl>
</dd>
<dt>RLON      longitude in true geog. system [deg. E];</dt><dd><dl class="simple">
<dt>RLON = f(gds)</dt><dd><p>at least one input field required in INCORE</p>
</dd>
</dl>
</dd>
<dt>SWISS_WE  West to East swiss coord. [m]</dt><dd><dl class="simple">
<dt>SWISS_WE = f(gds)</dt><dd><p>at least one input field required in INCORE</p>
</dd>
</dl>
</dd>
<dt>SWISS_SN  South to North swiss coord. [m]</dt><dd><dl class="simple">
<dt>SWISS_SN = f(gds)</dt><dd><p>at least one input field required in INCORE</p>
</dd>
</dl>
</dd>
<dt>BOAGAW_WE West to East Gauss-Boaga coord., west sector [m]</dt><dd><dl class="simple">
<dt>BOAGAW_WE = f(gds)</dt><dd><p>at least one input field required in INCORE</p>
</dd>
</dl>
</dd>
<dt>BOAGAW_SN South to North Gauss-Boaga coord., west sector [m]</dt><dd><dl class="simple">
<dt>BOAGAW_SN = f(gds)</dt><dd><p>at least one input field required in INCORE</p>
</dd>
</dl>
</dd>
<dt>BOAGAE_WE West to East Gauss-Boaga coord., east sector [m]</dt><dd><dl class="simple">
<dt>BOAGAE_WE = f(gds)</dt><dd><p>at least one input field required in INCORE</p>
</dd>
</dl>
</dd>
<dt>BOAGAE_SN South to North Gauss-Boaga coord., east sector [m]</dt><dd><dl class="simple">
<dt>BOAGAE_SN = f(gds)</dt><dd><p>at least one input field required in INCORE</p>
</dd>
</dl>
</dd>
<dt>HSURF     surface height [m]</dt><dd><dl class="simple">
<dt>HSURF = FIS / g</dt><dd><p>FIS: [required in INCORE]</p>
</dd>
</dl>
</dd>
</dl>
<p><strong>COSMO model, vertical coord. coefficients available, hybrid coordinates</strong></p>
<dl class="simple">
<dt>HHL       height of half level above msl [m];</dt><dd><dl class="simple">
<dt>HHL(k) = f(HSURF, gds)</dt><dd><p>HSURF: [required in INCORE, from COSMO]</p>
</dd>
</dl>
</dd>
<dt>HFL       height of full level above msl [m];</dt><dd><dl class="simple">
<dt>HFL(k) = f(HSURF, gds)</dt><dd><p>HSURF: [required in INCORE, from COSMO]</p>
</dd>
</dl>
</dd>
<dt>P0FL      pressure of reference atmosphere on full levels [Pa];</dt><dd><dl class="simple">
<dt>P0FL(k) = f(HSURF, gds)</dt><dd><p>HSURF: [required in INCORE, from COSMO]</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="soil-and-surface">
<h3>soil and surface<a class="headerlink" href="#soil-and-surface" title="Permalink to this heading">#</a></h3>
<dl>
<dt>RHO_SNOW  fresh snow density in [kg/m**3];</dt><dd><blockquote>
<div><dl>
<dt>RHO_SNOW = RHO_FRESH_SNOW(T), WHERE(mask=true)</dt><dd><p>RHO_FRESH_SNOW()  from Canadian land surface scheme
mask = TOT_PREC &gt; 0 and TOT_SNOW &gt; 0.8*TOT_PREC and T &lt; 3[C]
T    = T_2M            where T_2M &gt; 0[C] or T &#64; 850[hPa] is not defined</p>
<blockquote>
<div><p>T &#64; 850 [hPa]   elsewhere</p>
</div></blockquote>
<p>T_2M: scale = 1.0 (in [K]), time averaged
T &#64; 850 [hPa]: scale = 1.0 (in [K]), time averaged
TOT_PREC: accumulated in time
TOT_SNOW: accumulated in time</p>
<blockquote>
<div><p>Validity range of all parents must be the same, and
be at least 6 hour and at most 24 hour</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>This is based on the approach available in the Canadian land surface scheme
(Canadian Meteorological and Oceanographic Society, Atmosphere-Ocean 43 (3),
2006, pp. 207-222), which has been refined by the RHM for the Soshi games.</p>
<p>The significant temperature entering in the computation of the snow density
is T &#64; 850hPa, except when not available or when the 2m temperature is larger
than 0C; in these latter cases, the 2m temperature is taken.
Fresh snow density is diagnosed where at least 80% of the total precipitation
is in form of snow, and at the same time, the significant temperature is
smaller than 3C. The value of snow density is not defined elsewhere.</p>
</dd>
<dt>H_SNOW    snow depth in [m];</dt><dd><dl class="simple">
<dt>H_SNOW = W_SNOW / RHO_SNOW</dt><dd><p>RHO_SNOW:
W_SNOW:</p>
</dd>
</dl>
<p>fresh snow depth in [m];
H_SNOW = TOT_SNOW / RHO_SNOW
density of fresh snow should be computed with the operator
RHO_SNOW defined above.</p>
<blockquote>
<div><p>RHO_SNOW:
TOT_SNOW:</p>
</div></blockquote>
</dd>
<dt>T_G       temperature at boundary between ground and atmosphere (in [Kelvin]);</dt><dd><p>for grid points above water and for grid points on land that are not
covered with snow:
T_G = T_SO(lev=0)
For snow covered land points:
T_G = T_SNOW + (1. - MIN(1.,W_SNOW/15.0)) * (T_SO(lev=0)-T_SNOW)</p>
<blockquote>
<div><p>T_SNOW:
W_SNOW:               (in [mm])
T_S or T_SO(level 0):
FR_LAND:</p>
</div></blockquote>
</dd>
</dl>
</section>
<section id="mass-field">
<h3>mass field<a class="headerlink" href="#mass-field" title="Permalink to this heading">#</a></h3>
<dl>
<dt>PS        surface pressure in [Pa];</dt><dd><p>P = EXP( LNSP ), where LNSP represents the natural logarithm
of the surface pressure</p>
<blockquote>
<div><p>LNSP:</p>
</div></blockquote>
</dd>
<dt>QNH       pressure reduced at sea level, based on standard atmosphere [Pa];</dt><dd><dl>
<dt>QNH = PS * ( T0 / (T0-alpha*HSURF) )**n</dt><dd><blockquote>
<div><p>with T0 = 288.15 [K], alpha = 0.0065 [K/m], n = 5.256;
(in fact iterative version of this formula is used)</p>
</div></blockquote>
<p>PS: scale = 1.0 (in [Pa])
HSURF: scale = 1.0 (in [m])</p>
</dd>
</dl>
</dd>
<dt>P         pressure in [Pa];</dt><dd><dl>
<dt><a href="#id1"><span class="problematic" id="id2">**</span></a>* derived from reference pressure, P0FL, and PP</dt><dd><p>COSMO model
P = PP + P0FL             (P0FL can be computed in incore storage)</p>
<blockquote>
<div><p>PP:  scale = 100.0 (in [Pa])
P0FL: scale = 1.0 (in [Pa])</p>
</div></blockquote>
</dd>
<dt><a href="#id3"><span class="problematic" id="id4">**</span></a>* derived from surface pressure</dt><dd><p>IFS / GME models
P = Ak + Bk * PS</p>
<blockquote>
<div><p>PS: scale = 1.0 (in [Pa])
or</p>
</div></blockquote>
<dl class="simple">
<dt>P = Ak + Bk * exp(LNSP)</dt><dd><p>LNSP:</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>PP        pressure deviation in [hPa];</dt><dd><dl>
<dt><a href="#id5"><span class="problematic" id="id6">**</span></a>* derived from reference pressure, P0FL, and P</dt><dd><p>COSMO model
PP = 0.01 * (P - P0FL)      (P0FL can be computed in incore storage)</p>
<blockquote>
<div><p>P :  scale = 1.0 (in [Pa])
P0FL: scale = 1.0 (in [Pa])</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>PDIFF_CON pressure difference between cloud base and cloud top</dt><dd><dl>
<dt>PDIFF_CON(TOP_CON,BAS_CON,P) = P(BAS_CON) - P(TOP_CON)</dt><dd><p>TOP_CON:
BAS_CON:
P:        scale = 1.0 (in [Pa])</p>
<blockquote>
<div><p>= 0.01 (in [hPa])</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>FI        geopotential [m**2/s**2]:</dt><dd><dl>
<dt>FI = height * g, where g is the gravitational acceleration</dt><dd><dl class="simple">
<dt>HEIGHT: scale = 1.0 (HEIGHT in [m])</dt><dd><p>or</p>
</dd>
<dt>HHL<span class="classifier">scale = 1.0 (HHL in [m])</span></dt><dd><p>or</p>
</dd>
</dl>
<p>HFL   : scale = 1.0 (HFL in [m])</p>
</dd>
</dl>
</dd>
<dt>FIS       geopotential at surface [m**2/s**2]:</dt><dd><dl class="simple">
<dt>FIS = surface_height * g, where g is the gravitational acceleration</dt><dd><p>HSURF: scale = 1.0 (HSURF in [m])</p>
</dd>
</dl>
</dd>
<dt>HEIGHT     height [m]:</dt><dd><dl class="simple">
<dt><a href="#id7"><span class="problematic" id="id8">**</span></a>* derived from geopotential</dt><dd><dl class="simple">
<dt>HEIGHT = FI / g, where g is the gravitational acceleration</dt><dd><dl class="simple">
<dt>FI: scale = 1.0 (FI in [m**2/s**2])</dt><dd><p>… must be defined on half level</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><a href="#id9"><span class="problematic" id="id10">**</span></a>* derived from hydrostatic equation (IFS / GME model only)</dt><dd><dl class="simple">
<dt>HEIGHT(k) = f(T, QV, PS, FIS)</dt><dd><p>or</p>
</dd>
<dt>HEIGHT(k) = f(T, QV, LNSP, FIS)</dt><dd><p>T:      all levels between target level and lowest level (in[K])
QV:     all levels between target level and lowest level (in [kg/kg])
PS:     (in [Pa])</p>
</dd>
<dt>LNSP:</dt><dd><p>FIS:     (in [m**2/s**2])</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>HFL       height of full level above msl [m], COSMO hybrid coordinates:</dt><dd><dl>
<dt><a href="#id11"><span class="problematic" id="id12">**</span></a>* derived from geopotential</dt><dd><dl class="simple">
<dt>HFL = FI / g, where g is the gravitational acceleration</dt><dd><dl class="simple">
<dt>FI: scale = 1.0 (FI in [m**2/s**2])</dt><dd><p>… must be defined on full level</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><a href="#id13"><span class="problematic" id="id14">**</span></a>* derived from HHL (COSMO / ICON / GME model)</dt><dd><dl class="simple">
<dt>HFL(k) = 0.5 * [HHL(k)+HHL(k+1)]</dt><dd><p>HHL: scale = 1.0 (HFL in [m])</p>
</dd>
</dl>
</dd>
<dt><a href="#id15"><span class="problematic" id="id16">**</span></a>* derived from HSURF (COSMO model,</dt><dd><blockquote>
<div><p>vertical coord. coefficients available)</p>
</div></blockquote>
<dl class="simple">
<dt>HFL(k) = f(HSURF, gds)</dt><dd><p>HSURF: [required in INCORE, from COSMO]</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>HHL       height of half level above msl [m], COSMO hybrid coordinates:</dt><dd><dl>
<dt><a href="#id17"><span class="problematic" id="id18">**</span></a>* derived from geopotential</dt><dd><dl class="simple">
<dt>HHL = FI / g, where g is the gravitational acceleration</dt><dd><dl class="simple">
<dt>FI: scale = 1.0 (FI in [m**2/s**2])</dt><dd><p>… must be defined on half level</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><a href="#id19"><span class="problematic" id="id20">**</span></a>* derived from HSURF (COSMO model,</dt><dd><blockquote>
<div><p>vertical coord. coefficients available)</p>
</div></blockquote>
<dl class="simple">
<dt>HHL(k) = f(HSURF, gds)</dt><dd><p>HSURF: [required in INCORE, from COSMO]</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="wind">
<h3>wind<a class="headerlink" href="#wind" title="Permalink to this heading">#</a></h3>
<dl>
<dt>OMEGA_SLOPE                                                   (IFS model only)</dt><dd><p>Component of OMEGA, expressed as [Pa s-1].
Defined by etadot * dp/deta, where etadot is ECMWF deta/dt,
and etadot * dp/deta is an input needed by the program FLEXPART
(see <a class="reference external" href="https://www.flexpart.eu/">https://www.flexpart.eu/</a>).
ETADOT:
PS    :  [Pa]</p>
<blockquote>
<div><p>or</p>
</div></blockquote>
<p>ETADOT:
LNSP  :</p>
</dd>
<dt>DD        wind direction (in geog. coord.) [degree];</dt><dd><dl class="simple">
<dt>DD = 0.                           if U = V = 0.</dt><dd><p>180.0 + atan2(U, V)          otherwise</p>
</dd>
</dl>
<p>where U and V are wind components, either in geographical lat/lon reference
system or in native reference system (in this latter case the components
are first rotated from native to geographical reference system)</p>
<blockquote>
<div><p>U:
V:</p>
</div></blockquote>
</dd>
<dt>FF        wind velocity;</dt><dd><dl class="simple">
<dt>FF = sqrt( U*U + V*V )</dt><dd><p>U:  scale = 1.0 (FF in [m/s]),   = 1.94 (FF in [knots])
V:  scale = 1.0 (FF in [m/s]),   = 1.94 (FF in [knots])</p>
</dd>
</dl>
</dd>
<dt>DD_10M    10m-wind direction (in geog. coord.) [degree];</dt><dd><dl class="simple">
<dt>DD_10M = 0.                           if U_10M = V_10M = 0.</dt><dd><p>180.0 + atan2(U_10M, V_10M)  otherwise</p>
</dd>
</dl>
<p>where U_10M and V_10M are 10m wind components in geographical
lat/lon reference system</p>
<blockquote>
<div><p>U_10M:
V_10M:</p>
</div></blockquote>
</dd>
<dt>FF_10M    10m-wind velocity;</dt><dd><dl class="simple">
<dt>FF_10M = sqrt( U_10M*U_10M + V_10M*V_10M )</dt><dd><p>U_10M:  scale = 1.0 (FF in [m/s]),   = 1.94 (FF in [knots])
V_10M:  scale = 1.0 (FF in [m/s]),   = 1.94 (FF in [knots])</p>
</dd>
</dl>
</dd>
<dt>CFLDT     Courant-Friedrich-Levis number divided by the timestep [1/s]</dt><dd><dl class="simple">
<dt>CFLDT = abs(U)/dx + abs(V)/dy</dt><dd><p>When multiplied by the timestep of the actual simulation, it
corresponds to the CFL seen by the advection.
U: (on native mesh)
V: (on native mesh)</p>
</dd>
</dl>
</dd>
<dt>WDIV_3D  3D divergence of wind, computed on model surface [s-1]</dt><dd><dl class="simple">
<dt>WDIV_3D(U,V,W,HEIGHT)</dt><dd><p>U : (in [m/s], on k-surface, in native ref. system, staggered)
V : (in [m/s], on k-surface, in native ref. system, staggered)
W : (in [m/s], on model half levels)</p>
</dd>
</dl>
<p>HEIGHT or HHL : (in [m], on model half levels)
When computing WDIV_3D on level k, all listed fields must be available
on level k, HEIGHT and W must also be available on level k+1, U and V must
be available on at least one adjacent level (left or right derivative in k
is applied when k+1 or k-1 level is missing)</p>
</dd>
<dt>WDIV   horizontal divergence of wind, computed on model surface [s-1]</dt><dd><dl class="simple">
<dt>WDIV(U,V,W,HEIGHT)</dt><dd><p>U : (in [m/s], on k-surface, in native ref. system, staggered)
V : (in [m/s], on k-surface, in native ref. system, staggered)
W : (in [m/s])</p>
</dd>
</dl>
<p>HEIGHT or HHL : (in [m], on model half levels)
When computing WDIV on level k, all listed fields must be available
on level k, HEIGHT and W must also be available on level k+1, U and V must
be available on at least one adjacent level (left or right derivative in k
is applied when k+1 or k-1 level is missing)</p>
</dd>
<dt>WDEF_H    deformation of horizontal wind fiel, computedd on model surface [s-1]</dt><dd><dl class="simple">
<dt>WDEF_H(U,V,HEIGHT) = sqrt((dU/dx - dV/dy)**2 + (dV/dy + dU/dx)**2)</dt><dd><p>U : (in [m/s], on k-surface, in native ref. system, staggered)
V : (in [m/s], on k-surface, in native ref. system, staggered)</p>
</dd>
</dl>
<p>HEIGHT or HHL : (in [m], on model half levels)
When computing WDEF_H on level k, all listed fields must be available
on level k, HEIGHT must also be available on level k+1, U and V must
be available on at least one adjacent level (left or right derivative in k
is applied when k+1 or k-1 level is missing)</p>
</dd>
<dt>WSHEAR    vertical wind shear [s-1]</dt><dd><dl class="simple">
<dt>WSHEAR(U,V,HEIGHT) = sqrt((dU/dz)**2 + (dV/dz)**2)</dt><dd><p>U : (in [m/s], on k-surface, on base grid)
V : (in [m/s], on k-surface, on base grid)</p>
</dd>
</dl>
<p>HEIGHT or HHL : (in [m], on model half levels)
When computing WSHEAR on level k, all listed fields must be available
on level k, HEIGHT must also be available on level k+1, U and V must
be available on at least one adjacent level (left or right derivative in k
is applied when k+1 or k-1 level is missing)</p>
</dd>
<dt>WSHEARL   vertical wind shear integrated between lowest model level and 3km</dt><dd><p>above sea level [s-1]
WSHEARL(U,V,HEIGHT) = (1/h)*SUM(<a href="#id22"><span class="problematic" id="id23">|a-b|</span></a>) over all layers between surface</p>
<blockquote>
<div><blockquote>
<div><p>and 3km, where a and b are two wind vectors of
neighbouring layers, and h is the thickness over all
layers taken into account</p>
</div></blockquote>
<p>U : (in [m/s])
V : (in [m/s])</p>
</div></blockquote>
<p>HEIGHT or HHL : (in [m], on model half levels)</p>
</dd>
<dt>WSHEARM   vertical wind shear integrated between lowest model level and 6km</dt><dd><p>above sea level [s-1]
Calculated in the same way as WSHEARL.
Requires the same parent fields as WSHEARL</p>
</dd>
<dt>WSHEARU   vertical wind shear integrated between 3km (or lowest model level</dt><dd><p>if the surface is above 3km altitude) and 6km [s-1]
Calculated in the same way as WSHEARL.
Requires the same parend fields as WSHEARL</p>
</dd>
<dt>WSHEAR_0-1km   norm of vertical wind shear between lowest model level and</dt><dd><p>1km above sea level [m s-1]
U:  (in [m/s])
V:  (in [m/s])</p>
</dd>
<dt>WSHEAR_0-3km   norm of vertical wind shear between lowest model level and</dt><dd><p>3km above sea level [m s-1]
U:  (in [m/s])
V:  (in [m/s])</p>
</dd>
<dt>WSHEAR_0-6km   norm of vertical wind shear between lowest model level and</dt><dd><p>6km above sea level [m s-1]
U:  (in [m/s])
V:  (in [m/s])</p>
</dd>
<dt>WSHEAR_3-6km   norm of vertical wind shear between 3km and 6km above</dt><dd><p>sea level [m s-1]
U:  (in [m/s])
V:  (in [m/s])</p>
</dd>
<dt>ABSV        absolute vorticity on pressure surfaces [s-1]</dt><dd><blockquote>
<div><p>Vertical component of the absolute vorticity
computed using smoothed wind fields on p-levels.
This is a rough approximation of the “real” absolute vorticity,
which is perpendicular to constant height levels.</p>
</div></blockquote>
<p>U : (in [m/s], on p-surface, in native ref. system)
V : (in [m/s], on p-surface, in native ref. system)</p>
</dd>
<dt>RELV        relative vorticity on pressure surfaces [s-1]</dt><dd><blockquote>
<div><p>Vertical component of the relative vorticity
computed using smoothed wind fields on p-levels.
This is a rough approximation of the “real” relative vorticity,
which is perpendicular to constant height levels.</p>
</div></blockquote>
<p>U : (in [m/s], on p-surface, in native ref. system)
V : (in [m/s], on p-surface, in native ref. system)</p>
</dd>
<dt>POT_VORTIC  potential vorticity on model surface [K m2 kg-1 s-1]</dt><dd><dl>
<dt>POT_VORTIC  =  (1./rho) * [del Theta * ( curl v + 2 Omega )]</dt><dd><dl class="simple">
<dt>where rho       is the total air density</dt><dd><p>del Theta is the gradient of the potential temperature
curl v    is the curl of the wind
2 Omega   is the Coriolis term</p>
</dd>
</dl>
<p>Effect of water loading is normally ignored, but can be included
by setting out_mode_ignore_wloading to false.</p>
<blockquote>
<div><p>QV : (in [kg/kg])
QC : (in [kg/kg])
QI : (in [kg/kg])</p>
<blockquote>
<div><p>U : (in [m/s], on k-surface, in native ref. system, staggered)
V : (in [m/s], on k-surface, in native ref. system, staggered)
W : (in [m/s])
P : (in [Pa])
T : (in [K])</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<p>HEIGHT or HHL : (in [m], on model half levels)
… only when out_mode_ignore_wloading=.F., depending on the list</p>
<blockquote>
<div><p>specified in &amp;ModelSpecification: one or more of
QR : (in [kg/kg])
QS : (in [kg/kg])
QG : (in [kg/kg])
…</p>
</div></blockquote>
<p>When computing POT_VORTIC on level k, all listed fields must be available
on level k, W and HEIGHT must also be available on level k+1, U, V, P, T must
be available on at least one adjacent level (left or right derivative in k
is applied when k+1 or k-1 level is missing)</p>
</dd>
</dl>
</section>
<section id="quasi-geostrophic-approximation">
<h3>quasi-geostrophic approximation<a class="headerlink" href="#quasi-geostrophic-approximation" title="Permalink to this heading">#</a></h3>
<p>U_G        eastward component of geostrophic wind on model surface in native ref. system [m/s]
V_G        northward component of geostrophic wind on model surface in native ref. system [m/s]</p>
<blockquote>
<div><dl>
<dt>(U_G,V_G) = -1/(rho*f) (e_r) x (grad p)</dt><dd><dl>
<dt>where rho       is the total air density</dt><dd><p>grad p    is the pressure gradient
f         is the Coriolis factor 2 Omega sin(lat)
e_r       is the radial base vector for spherical polar</p>
<blockquote>
<div><p>coordinates</p>
</div></blockquote>
</dd>
</dl>
<p>Effect of water loading is normally ignored, but can be included
by setting out_mode_ignore_wloading to false.</p>
<blockquote>
<div><blockquote>
<div><p>P : (in [Pa])
T : (in [K])</p>
</div></blockquote>
<p>QC : (in [kg/kg])
QV : (in [kg/kg])
QI : (in [kg/kg])</p>
</div></blockquote>
</dd>
</dl>
<p>HEIGHT or HHL : (in [m], on model half levels)
… only when out_mode_ignore_wloading=.F., depending on the list</p>
<blockquote>
<div><dl class="simple">
<dt>specified in &amp;ModelSpecification: one or more of</dt><dd><p>QR : (in [kg/kg])
QS : (in [kg/kg])
QG : (in [kg/kg])</p>
</dd>
</dl>
<p>…</p>
</div></blockquote>
<p>When computing U_G (respectively V_G) on level k, all listed fields must be
available on level k, HEIGHT must also be available on level k+1, P must be
available on at least one adjacent level (left or right derivative in k
is applied when k+1 or k-1 level is missing)</p>
</div></blockquote>
<dl>
<dt>DD_G       direction of geostrophic wind (in geog. coord.) [degree];</dt><dd><dl class="simple">
<dt>DD_G = 0.                         if U_G = V_G = 0.</dt><dd><p>180.0 + atan2(U_G, V_G)      otherwise</p>
</dd>
</dl>
<p>where U_G and V_G are the components of the geostrophic wind, either in
geographical lat/lon reference system or in native reference system (in this
latter case the components are first rotated from native to geographical
reference system)</p>
<blockquote>
<div><p>U_G: (in [m/s])
V_G: (in [m/s])</p>
</div></blockquote>
</dd>
<dt>FF_G       velocity of the geostrophic wind [m/s];</dt><dd><dl class="simple">
<dt>FF_G = sqrt( U_G*U_G + V_G*V_G )</dt><dd><p>U_G:  scale = 1.0 (FF_G in [m/s]),   = 1.94 (FF_G in [knots])
V_G:  scale = 1.0 (FF_G in [m/s]),   = 1.94 (FF_G in [knots])</p>
</dd>
</dl>
</dd>
</dl>
<p>RELV_G      relative geostrophic vorticity on model surface [s-1]
ABSV_G      absolute geostrophic vorticity on model surface [s-1]</p>
<blockquote>
<div><p>RELV_G  =  [e_r * ( curl v_g )]
ABSV_G  =  [e_r * ( curl v_g + 2 Omega )]</p>
<blockquote>
<div><dl>
<dt>where curl v_g  is the curl of the geostrophic wind v_g = (U_G,V_G)</dt><dd><blockquote>
<div><dl class="simple">
<dt>e_r       is the radial base vector for spherical polar</dt><dd><p>coordinates</p>
</dd>
</dl>
<p>2 Omega   is the Coriolis term</p>
</div></blockquote>
<p>U_G : (in [m/s], on k-surface, in native ref. system)
V_G : (in [m/s], on k-surface, in native ref. system)</p>
</dd>
</dl>
</div></blockquote>
<p>HEIGHT or HHL : (in [m], on model half levels)
When computing RELV_G (respectively ABSV_G) on level k, all listed fields
must be available on level k, HEIGHT must also be available on level k+1, U_G
and V_G must be available on at least one adjacent level (left or right
derivative in k is applied when k+1 or k-1 level is missing)</p>
</div></blockquote>
<p>RELV_ADV_G  relative geostrophic vorticity advection on model surface [s-1 m-1]
ABSV_ADV_G  absolute geostrophic vorticity advection on model surface [s-1 m-1]</p>
<blockquote>
<div><p>RELV_ADV_G  =  - [ v_g * grad RELV_G ]
ABSV_ADV_G  =  - [ v_g * grad ABSV_G ]</p>
<blockquote>
<div><dl>
<dt>where v_g  is the geostrophic wind (U_G,V_G)</dt><dd><blockquote>
<div><p>grad RELV_G is the gradient of the relative geostrophic vorticity
grad ABSV_G is the gradient of the absolute geostrophic vorticity</p>
</div></blockquote>
<p>RELV_G : (in [s-1], on k-surface)
ABSV_G : (in [s-1], on k-surface)
U_G : (in [m/s], on k-surface, in native ref. system)
V_G : (in [m/s], on k-surface, in native ref. system)</p>
</dd>
</dl>
</div></blockquote>
<p>HEIGHT or HHL : (in [m], on model half levels)
When computing RELV_ADV_G (respectively ABSV_ADV_G) on level k, all listed
fields must be available on level k, HEIGHT must also be available on level k+1,
RELV_ADV (respectively ABSV_ADV) must be available on at least one adjacent
level (left or right derivative in k is applied when k+1 or k-1 level is missing)</p>
</div></blockquote>
<dl>
<dt>THICK_ADV_G  geostrophic thickness advection for layer between two p-surfaces p1 &lt; p2 [m s-1]</dt><dd><dl class="simple">
<dt>THICK_ADV_G  =  - [ v_g * grad ( h(p1) - h(p2) ) ]</dt><dd><dl class="simple">
<dt>where v_g  is the geostrophic wind (U_G,V_G)</dt><dd><p>h(p) is the height of the p-surface</p>
</dd>
</dl>
</dd>
</dl>
<p>U_G : (in [m/s], on p-surface, in geog. ref. system)
V_G : (in [m/s], on p-surface, in geog. ref. system)
HEIGHT : (in [m], on pressure surface)
When computing THICK_ADV_G for the layer between the two p-surfaces p1 and p2
U_G, V_G, and HEIGHT must be available on p1 and p2. The value of THICK_ADV_G
is set to undefined if the directional shear of the geostrophic wind between p1
and p2 is larger than 90 degrees.</p>
</dd>
</dl>
</section>
<section id="radiation">
<h3>radiation<a class="headerlink" href="#radiation" title="Permalink to this heading">#</a></h3>
<dl>
<dt>ASOD_SH   global (downward) shortwave radiation at surface level on horizontal</dt><dd><p>plane [W/m**2].
(1)  ASOD_SH = max( ASOB_SH / max((1.-ALB_RAD) , 1.e-10) , 0. )
Note: ASOB_SH is cumulated in time, ALB_RAD is instantaneous,</p>
<blockquote>
<div><blockquote>
<div><p>which means this is only an approximation (but in most
cases ALB_RAD does not vary strongly within the time
scale of two model output)</p>
</div></blockquote>
<p>ASOB_SH:     toper = tdelta
ALB_RAD:    scale = 0.01</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>ASOD_SH = ASWDIFD_S + ASWDIR_SH
ASWDIR_SH:  toper = tdelta
ASWDIFD_S:  toper = tdelta</p></li>
</ol>
</dd>
<dt>GLOB      global (downward) shortwave radiation at surface level [W/m**2];</dt><dd><p>on terrain following plane when radiative topo corrections are
active, on horizontal plane otherwise.
(1)  GLOB = max( ASOB_S / max((1.-ALB_RAD) , 1.e-10) , 0. )
Note: ASOB_S is cumulated in time, ALB_RAD is instantaneous,</p>
<blockquote>
<div><blockquote>
<div><p>which means this is only an approximation (but in most
cases ALB_RAD does not vary strongly within the time
scale of two model output)</p>
</div></blockquote>
<p>ASOB_S:     toper = tdelta
ALB_RAD:    scale = 0.01</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>GLOB = ASWDIFD_S + ASWDIR_S
ASWDIR_S:   toper = tdelta
ASWDIFD_S:  toper = tdelta</p></li>
</ol>
</dd>
</dl>
<p>ASWDIR_S  (if radiative topo corrections are not active)
ASWDIR_SH (if radiative topo corrections are active)</p>
<blockquote>
<div><p>direct shortwave radiation at surface level on horizontal
plane [W/m**2]; empirical model implemented following Perez et
al. (1992) and the code of Antoine Zelenka / MeteoSwiss.
Note 1: when available, it is recommended to use direct model output</p>
<blockquote>
<div><p>instead</p>
</div></blockquote>
<p>Note 2: radiation_topo_corrected in &amp;ModelSpecification must be defined
(1) when radiative topo corrections are not active</p>
<blockquote>
<div><p>GLOB:     [W/m**2]
TD_2M:    [K]
HSURF:    [m]</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>when radiative topo corrections are active
ASOD_SH:  [W/m**2]
TD_2M:    [K]
HSURF:    [m]</p></li>
</ol>
</div></blockquote>
<dl>
<dt>ASWDIFD_S diffuse shortwave radiation at surface level [W/m**2]; empirical model</dt><dd><p>implemented following Perez et al. (1992) and the code of Antoine
Zelenka / MeteoSwiss
Note 1: when available, it is recommended to use direct model output</p>
<blockquote>
<div><p>instead</p>
</div></blockquote>
<p>Note 2: radiation_topo_corrected in &amp;ModelSpecification must be defined
(1) when radiative topo corrections are not active</p>
<blockquote>
<div><p>GLOB:     [W/m**2]
TD_2M:    [K]
HSURF:    [m]</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>when radiative topo corrections are active
ASOD_SH:  [W/m**2]
TD_2M:    [K]
HSURF:    [m]</p></li>
</ol>
</dd>
<dt>ASOD_SvX  (X=E,S,W,N)</dt><dd><p>global shortwave radiation on vertical oriented surfaces
at surface level [W/m**2]; model implemented following Perez
et al. (1987) and the code of Antoine Zelenka / MeteoSwiss
(1) when radiative topo corrections are not active</p>
<blockquote>
<div><p>GLOB:       [W/m**2]
ASWDIR_S:   toper = tdelta [W/m**2]
ASWDIFD_S:  toper = tdelta [W/m**2]
ALB_RAD:    scale=0.01
HSURF:      [m]</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>when radiative topo corrections are active
ASOD_SH:    [W/m**2]
ASWDIR_SH:  toper = tdelta [W/m**2]
ASWDIFD_S:  toper = tdelta [W/m**2]
ALB_RAD:    scale=0.01
HSURF:      [m]</p></li>
</ol>
</dd>
<dt>ATHD_S_TG  incoming longwave radiation at surface level, based on T(ground) [W/m**2];</dt><dd><p>Note that at grid points without snow: T(ground) = T(surf)
ATHD_S_TG = (1/emissivity) * (ATHB_S + emissivity*boltzman*T(ground)**4)</p>
<blockquote>
<div><p>ATHB_S: toper = tdelta
T_G:</p>
</div></blockquote>
</dd>
<dt>ATHD_S_TS  incoming longwave radiation at surface level, based on T(surf) [W/m**2]</dt><dd><dl class="simple">
<dt>ATHD_S_TS = (1/emissivity) * (ATHB_S + emissivity*boltzman*T(surf)**4)</dt><dd><p>ATHB_S: toper = tdelta
T_S or T_SO(level 0):</p>
</dd>
</dl>
</dd>
<dt>ATHD_S_T2M incoming longwave radiation at surface level, based on T_2M [W/m**2]</dt><dd><dl class="simple">
<dt>ATHD_S_T2M = (1/emissivity) * (ATHB_S + emissivity*boltzman*T_2M**4)</dt><dd><p>ATHB_S: toper = tdelta
T_2M:</p>
</dd>
</dl>
</dd>
<dt>LUM       luminosity [klux];</dt><dd><p>LUM = 0.001 * EXP{ LOG(GLOB/0.013) / 0.963 }
(1) GLOB computed from radiation budget</p>
<blockquote>
<div><p>ASOB_S:     toper = tdelta
ALB_RAD:    scale = 0.01</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>GLOB computed from radiation components
ASWDIR_S:   toper = tdelta
ASWDIFD_S:  toper = tdelta</p></li>
</ol>
</dd>
<dt>DURSUN_M  maximum sunshine duration [s];</dt><dd><p>Compute maximal sunshine duration, using solar geometry only; the
solar refraction in the atmosphere is not considered. When
out_mode_sun_topo is true, the topography derived horizon is
considered and the parent field HORIZON must be present, otherwise
the horizon is defined everywhere with an elevation of 0 deg.
The parent field DURSUN must be present, and DURSUN_M is computed
for the same time intervals as DURSUN.
(1) out_mode_sun_topo = .false.</p>
<blockquote>
<div><p>DURSUN:    [s]</p>
</div></blockquote>
<ol class="arabic" start="2">
<li><p>out_mode_sun_topo = .true.
DURSUN:    [s]
HORIZON: elevation in [degree], for n sectors coded as levels;</p>
<blockquote>
<div><p>all sectors (levels) must be present.</p>
</div></blockquote>
</li>
</ol>
</dd>
<dt>DURSUN_R  relative sunshine duration [%];</dt><dd><p>When DURSUN_M is missing, DURSUN_M will be computed internally
on the fly (see description of DURSUN_M).
(1) DURSUN_M available in list of parents
DURSUN_R = 100. * DURSUN / DURSUN_M</p>
<blockquote>
<div><p>DURSUN:    [s]
DURSUN_M:  [s]</p>
</div></blockquote>
<ol class="arabic" start="2">
<li><p>DURSUN_M missing, out_mode_sun_topo = .false.
DURSUN:    [s]</p></li>
<li><p>DURSUN_M missing, out_mode_sun_topo = .true.
DURSUN:    [s]
HORIZON: elevation in [degree], for n sectors coded as levels;</p>
<blockquote>
<div><p>all sectors (levels) must be present.</p>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
</section>
<section id="thermodynamic-quantities">
<h3>thermodynamic quantities<a class="headerlink" href="#thermodynamic-quantities" title="Permalink to this heading">#</a></h3>
<dl>
<dt>DEN       total density of air mixture (in [kg/m**3]).</dt><dd><p>Based on perfect gas law, pressure as sum of partial pressures.
Effect of water loading is normally ignored, but can be included
by setting out_mode_ignore_wloading to false.
DEN = f(T, P, QV, QC, QI, [QR, QS, QG …])</p>
<blockquote>
<div><p>T:  [K]
P:  [Pa]
QV:  [kg/kg]
QC:  [kg/kg]
QI:  [kg/kg]</p>
</div></blockquote>
<dl class="simple">
<dt>… only when out_mode_ignore_wloading=.F., depending on the list</dt><dd><p>specified in &amp;ModelSpecification: one or more of
QR : [kg/kg]
QS : [kg/kg]
QG : [kg/kg]
…</p>
</dd>
</dl>
</dd>
<dt>THETA    potential temperature (in [K])</dt><dd><dl class="simple">
<dt>THETA = T * (1.E5/P)**(pc_r_d/pc_c_p)</dt><dd><p>T:    (in [K])
P:    (in [Pa])</p>
</dd>
</dl>
</dd>
<dt>THETA_2M 2m potential temperature (in [K])</dt><dd><p>The surface pressure is reduced hydrostatically to a 2 meter pressure,
using constant temperature T_2M; the previous formula for THETA is then used.</p>
<blockquote>
<div><p>T_2M:   (in [K])
PS:     (in [P])</p>
</div></blockquote>
</dd>
<dt>THETAE    equivalent potential temperature (in [K])</dt><dd><dl class="simple">
<dt>THETAE = T * (1.E5/P)**(pc_r_d/pc_c_p) * exp((L*m)/(pc_c_p*T)),</dt><dd><p>where pc_r_d (gas constant for dry air), pc_c_p (specific
heat), L (latent heat of water vapor) and m=QV/(1-QV)
T:  offset = 0. (in [K])
P:  offset = 0. (in [Pa])
QV:</p>
</dd>
</dl>
</dd>
<dt>THETAE_2M 2m-equivalent potential temperature (in [K])</dt><dd><p>The surface pressure is reduced hydrostatically to a 2 meter pressure,
using constant temperature T_2M; QV_2M is computed on the basis of this
reduced pressure and of TD_2M; the previous formula for THETAE is then used.</p>
<blockquote>
<div><p>T_2M:  offset = 0. (in [K])
PS:    offset = 0. (in [P])
TD_2M: offset = 0. (in [K])</p>
</div></blockquote>
</dd>
<dt>THETA_V   virtual potential temperature (in [K])</dt><dd><dl>
<dt>THETA_V = T * (1.E5/P)**(pc_r_d/pc_cp_d) *       &amp;</dt><dd><blockquote>
<div><p>(1+(((pc_r_v / pc_r_d) - 1.0)*QV/(1-QV))) ,</p>
</div></blockquote>
<p>where pc_r_d (gas constant for dry air), pc_cp_d (specific
heat of dry air), pc_r_v (Gas constant for water vapor),
pc_r_d (Gas constant for dry air)
T:  offset = 0. (in [K])
P:  offset = 0. (in [Pa])
QV:</p>
</dd>
</dl>
</dd>
<dt>THETA_V_2M  2-m virtual potential temperature (in [K])</dt><dd><p>The surface pressure is reduced hydrostatically to a 2 meter pressure,
using constant temperature T_2M; QV_2M is computed on the basis of this
reduced pressure and of TD_2M; the previous formula for THETA_V is then used.</p>
<blockquote>
<div><p>T_2M:  offset = 0. (in [K])
PS:  offset = 0. (in [Pa])
TD_2M:</p>
</div></blockquote>
</dd>
<dt>TW        wet bulb temperature [K];</dt><dd><ol class="arabic simple">
<li><p>If out_mode_tw_iterative = .TRUE., a secant method is used to solve the
psychrometric equation (cf. Bohren and Albrecht, 1998, equation (6.72)).
Undefined values is produced where the secant method does not converge,
and a warning is generated.</p></li>
</ol>
<dl class="simple">
<dt>TW = f(T,P,QV)</dt><dd><p>T:      (in[K])
P:      (in[Pa])
QV:     (in[kg/kg])</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>If out_mode_tw_iterative = .FALSE., an approximation formula is used
(as in cosmo pp_utilities:calsnowlmt, after after Egger/Joss).</p></li>
</ol>
<dl class="simple">
<dt>TW = f(T,P,TD)</dt><dd><p>T:      (in[K])
P:      (in[Pa])
TD:     (in[kg/kg])
or</p>
</dd>
<dt>TW = f(T,P,td(QV,P))</dt><dd><p>T:      (in[K])
P:      (in[Pa])
QV:     (in[kg/kg])</p>
</dd>
</dl>
</dd>
<dt>TW_2M     2m wet bulb temperature [K];</dt><dd><p>The surface pressure is reduced hydrostatically to a 2 meter pressure,
using constant temperature T_2M.
The algorithm is chosen in analogy to TW.
(1) If out_mode_tw_iterative = .TRUE., a secant method is used to solve the</p>
<blockquote>
<div><p>psychrometric equation (cf. Bohren and Albrecht, 1998, equation (6.72)).
Undefined values is produced where the secant method does not converge,
and a warning is generated.</p>
</div></blockquote>
<dl class="simple">
<dt>TW_2M = f(T_2M,PS,QV_2M)</dt><dd><p>T_2M:      (in[K])
PS:        (in[Pa])
QV_2M:     (in[kg/kg])</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>If out_mode_tw_iterative = .FALSE., an approximation formula is used
(as in cosmo pp_utilities:calsnowlmt, after after Egger/Joss).</p></li>
</ol>
<dl class="simple">
<dt>TW_2M = f(T_2M,PS,TD_2M)</dt><dd><p>T_2M:      (in[K])
PS:        (in[Pa])
TD_2M:     (in[kg/kg])
or</p>
</dd>
<dt>TW_2M = f(T_2M,PS,td(QV_2M,PS))</dt><dd><p>T_2M:      (in[K])
PS:        (in[Pa])
QV_2M:     (in[kg/kg])</p>
</dd>
</dl>
</dd>
<dt>TD        dew point temperature (in [Kelvin]);</dt><dd><dl class="simple">
<dt>TD = f(P,QV)</dt><dd><p>QV:
P: offset = 0. (in [Pa])</p>
</dd>
</dl>
</dd>
<dt>TD_2M     2m-dew point temperature (in [Kelvin]);</dt><dd><p>The surface pressure is reduced hydrostatically to a 2 meter pressure,
using constant temperature T_2M, and the dew point is then calculated
using this reduced pressure and QV_2M; TD_2M is constraint to be
smaller or equal to T_2M.
TD_2M = f(PS,QV_2M,T_2M)</p>
<blockquote>
<div><p>QV_2M: (in [kg/kg])
PS:    (in [Pa])
T_2M:  (in [K])</p>
</div></blockquote>
</dd>
<dt>D_TD      dew point depression;</dt><dd><dl class="simple">
<dt>D_TD = MAX(T - TD, 0)   where TD = f(P,QV)</dt><dd><p>QV:
T: offset = 0. (in [K])
P: offset = 0. (in [Pa])</p>
</dd>
</dl>
</dd>
<dt>D_TD_2M   2m-dew point depression;</dt><dd><p>Compute TD_2M using PS, QV_2M and T_2M (see TD_2M), and then
compute the depression
D_TD_2M = MAX(T_2M - f(PS,QV_2M,T_2M), 0)</p>
<blockquote>
<div><p>PS:    (in [Pa])
QV_2M: (in [kg/kg])
T_2M:  (in [K])</p>
</div></blockquote>
<p>or
D_TD_2M = MAX(T_2M - TD_2M, 0)</p>
<blockquote>
<div><p>TD_2M:
T_2M:</p>
</div></blockquote>
</dd>
<dt>ENTH      enthalpy (heat content) of air based on specific humidity and temperature</dt><dd><p>[J/kg];
ENTH = f(QV,T)</p>
<blockquote>
<div><p>QV:     (in [kg/kg])
T:      (in[K])</p>
</div></blockquote>
</dd>
<dt>ENTH_2M   2m enthalpy (heat content) of air based on specific humidity and temperature</dt><dd><p>[J/kg];
ENTH_2M = f(QV_2M,T_2M)</p>
<blockquote>
<div><p>QV_2M:     (in [kg/kg])
T_2M:      (in[K])</p>
</div></blockquote>
</dd>
<dt>QV        specific humidity based on pressure and dew point [kg/kg];</dt><dd><dl class="simple">
<dt>QV = f(TD,P)</dt><dd><p>TD:  (in[K])
P:   (in [Pa])</p>
</dd>
</dl>
</dd>
<dt>QV_SAT    specific humidity at staturation [kg/kg];</dt><dd><p>The specific humidity at saturation uses the same formula as for the
computation of the specific humidity, but takes T instead of TD as first
argument.
QV_SAT = f(T,P)</p>
<blockquote>
<div><p>T:   (in[K])
P:   (in [Pa])</p>
</div></blockquote>
</dd>
<dt>QV_2M     2m specific humidity based on surface pressure and dew point [kg/kg];</dt><dd><p>The surface pressure is reduced hydrostatically to a 2 meter pressure,
using constant temperature T_2M.
QV_2M = f(TD_2M,PS,T_2M)</p>
<blockquote>
<div><p>TD_2M:  (in[K])
PS:     (in [Pa])
T_2M:   (in[K])</p>
</div></blockquote>
</dd>
<dt>QV_SAT_2M 2m specific humidity at saturation [kg/kg];</dt><dd><p>The specific humidity at saturation uses the same formula as for the
computation of the specific humidity, but takes T_2M instead of TD_2M
as first argument.
QV_SAT_2M = f(T_2M,PS,T_2M)</p>
<blockquote>
<div><p>T_2M:   (in[K])
PS:     (in [Pa])</p>
</div></blockquote>
</dd>
<dt>MIXRAT    mixing ratio;</dt><dd><dl class="simple">
<dt>MIXRAT = QV/(1-QV)</dt><dd><p>QV:     (in [kg/kg])</p>
</dd>
</dl>
</dd>
<dt>MIXRAT_2M 2m mixing ratio;</dt><dd><dl class="simple">
<dt>MIXRAT_2M = QV_2M/(1-QV_2M)</dt><dd><p>QV_2M:  (in [kg/kg])</p>
</dd>
</dl>
</dd>
<dt>RELHUM    relative humidity over water [%];</dt><dd><blockquote>
<div><p>RELHUM = 100 * PVsat_water(TD)/PVsat_water(T)
(standard physical definition)</p>
<blockquote>
<div><p>T: offset = 0. (in [K])
TD: offset = 0. (in [K])</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>or</dt><dd><p>RELHUM = 100 * QV/QVsat_water(T,P)
(COSMO definition, which is an approximation of WMO definition)</p>
<blockquote>
<div><p>T: offset = 0. (in [K])
QV:
P: offset = 0. (in [Pa])</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>RELHUM_2M 2m-relative humidity over water [%];</dt><dd><blockquote>
<div><p>RELHUM = 100 * PVsat_water(TD_2M)/PVsat_water(T_2M)
(standard physical definition)</p>
<blockquote>
<div><p>T_2M: offset = 0. (in [K])
TD_2M: offset = 0. (in [K])</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>or</dt><dd><p>RELHUM_2M = 100 * QV_2M/QVsat_water(T_2M,p2m(PS,T_2M))
(COSMO definition, which is an approximation of WMO definition)
where p2m is the surface pressure ihydrostatically reduced to a
2 meter pressure, using constant temperature T_2M.</p>
<blockquote>
<div><p>T_2M: offset = 0. (in [K])
QV_2M:
PS: offset = 0. (in [Pa])</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>RH_ICE    relative humidity over ice [%];</dt><dd><dl class="simple">
<dt>RH_ICE = 100 * QV/QVsat_ice(T,P)</dt><dd><p>T: offset = 0. (in [K])
QV:
P: offset = 0. (in [Pa])</p>
</dd>
</dl>
</dd>
<dt>RH_MIX_EC  relative humidity over mixed phase [%];</dt><dd><p>Pressure of water vapor over mixed phase computed according to (see formula 1.11 ad 1.12)
<a class="reference external" href="http://www.ecmwf.int/sites/default/files/elibrary/2015/9208-part-i-observation-processing.pdf">http://www.ecmwf.int/sites/default/files/elibrary/2015/9208-part-i-observation-processing.pdf</a>
In particular, RH_MIX_EC = RELHUM (if T &gt; 0C)</p>
<blockquote>
<div><blockquote>
<div><p>= RH_ICE (if T &lt; -23C).</p>
</div></blockquote>
<dl class="simple">
<dt>RH_MIX_EC = 100 * QV/QVsat_mix(T,P)</dt><dd><p>T: offset = 0. (in [K])
QV:
P: offset = 0. (in [Pa])</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>CLI_RATIO cloud ice ratio [%]</dt><dd><dl>
<dt>CLI_RATIO = 100. * (QI/(QI + QC))</dt><dd><blockquote>
<div><p>where denominator larger than out_cloud_min, undef otherwise</p>
</div></blockquote>
<p>QI:
QC:</p>
</dd>
</dl>
</dd>
<dt>T_2M_SNOWC snow corrected 2m temperature;</dt><dd><dl>
<dt>T_2M_SNOWC = T_2M              if W_SNOW &lt; 0.1</dt><dd><blockquote>
<div><p>= T(lowest level)   if W_SNOW &gt; 0.1</p>
</div></blockquote>
<p>W_SNOW, T_2M, T(lowest level):
T_2M, TD_2M:</p>
</dd>
</dl>
</dd>
<dt>TTOP_CON  temperature at cloud top</dt><dd><dl class="simple">
<dt>TTOP_CON = T(TOP_CON)</dt><dd><p>TOP_CON:
T:        offset = 0.0 (in [K])</p>
</dd>
</dl>
</dd>
</dl>
<p>HZEROCL   height of the zero degree Centigrade isotherm [m asl].</p>
<blockquote>
<div><p>T is evaluated from 8000m agl down to the lowest model level;
HZEROCL is set to the height where zero degree Centigrade is
reached for the first time. If T never reaches zero degree
Centigrade, or the model atmosphere is too shallow, HZEROCL
is set to undefined.
When out_mode_h0cl_extrapolate is set to true, the algorithm also
considers zero degree Centigrade isotherm below lowest model level.
In this case, a constant lapse rate derived from the temperature at
the two lowest model levels is assumed, and the zero degree isotherm
is based on the extrapolated T profile. When the lapse rate is
negative, or when the zero degree Centigrade isotherm is lower
than 0 m asl, HZEROCL is set to undefined.</p>
<dl>
<dt>HZEROCL = f(T, HEIGHT, HSURF)</dt><dd><p>T :  (in [K])</p>
</dd>
<dt>HEIGHT or HHL or HFL<span class="classifier">(in [m asl])</span></dt><dd><blockquote>
<div><p>HSURF :  (in [m asl])</p>
</div></blockquote>
<dl class="simple">
<dt>… both T and HEIGHT must be defined on same type of</dt><dd><p>model levels (either full or half levels)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>HEATX      heat index (in [�K]):</dt><dd><blockquote>
<div><p>A “discomfort” index resulting from a multiple regression
analysis performed on data obtained in extensive bio-
meteorological studies (Steadman R.G., 1979, Rothfusz L.P., 1990).
Computed with or without adjustments by NOAA
(<a class="reference external" href="http://www.crh.noaa.gov/gjt/Weather_Info/heat_index.php">http://www.crh.noaa.gov/gjt/Weather_Info/heat_index.php</a>)
Evaluated for
T_2M &gt; 80�F and RELHUM_2M &gt; 40% if out_mode_adjusted = .F.
T_2M &gt; 80�F and RELHUM_2M &gt;  0% if out_mode_adjusted = .T.</p>
</div></blockquote>
<p>T_2M : offset = 0.     (conversion in �F in the code)
RELHUM_2M : offset = 0.
or
T_2M : offset = 0.     (conversion in �F in the code)
TD_2M : offset = 0.</p>
</dd>
<dt>UTCI_SHADOW universal thermal climate index ( in [�K])</dt><dd><blockquote>
<div><p>“Discomfort index” developed in the framework of COST Action 730,
based on multiple regression analysis on data obtained from
a thermoregulation model (Jendritzky G. et al., 2009).
Computed without contribution of direct incident shortwave
radiation.</p>
</div></blockquote>
<p>T_2M: in [K]
TD_2M: in [K]
ATHD_S: toper = tdelta, in [W/m**2]
ATHU_S: toper = tdelta, in [W/m**2]
ASWDIFD_S: toper = tdelta, in [W/m**2]
ASWDIFU_S: toper = tdelta, in [W/m**2]
FF_10M: in [m/s]</p>
</dd>
<dt>UTCI_SUN   universal thermal climate index ( in [�K])</dt><dd><blockquote>
<div><p>Computed with contribution of direct incident shortwave radiation.
Uses all parent fields of UTCI_SHADOW, and additionally</p>
</div></blockquote>
<p>T_2M: in [K]
TD_2M: in [K]
ATHD_S: toper = tdelta, in [W/m**2]
ATHU_S: toper = tdelta, in [W/m**2]
ASWDIFD_S: toper = tdelta, in [W/m**2]
ASWDIFU_S: toper = tdelta, in [W/m**2]
ASWDIR_S: toper = tdelta, in [W/m**2]
FF_10M: in [m/s]</p>
</dd>
</dl>
</section>
<section id="precipitation-and-moisture-transport">
<h3>precipitation and moisture transport<a class="headerlink" href="#precipitation-and-moisture-transport" title="Permalink to this heading">#</a></h3>
<dl>
<dt>TOT_PREC  Total precipitation;</dt><dd><dl class="simple">
<dt>TOT_PREC = linear combination of components</dt><dd><dl class="simple">
<dt>coefficients and components: as defined by precip_all in &amp;ModelSpecification</dt><dd><p>(main parent is first element of list)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>TOT_GSP   Total grid-scale precipitation;</dt><dd><dl class="simple">
<dt>TOT_GSP  = linear combination of components</dt><dd><dl class="simple">
<dt>coefficients and components: as defined by precip_gridscale in &amp;ModelSpecification</dt><dd><p>(main parent is first element of list)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>TOT_CON   Total convective precipitation;</dt><dd><dl class="simple">
<dt>TOT_CON = linear combination of components</dt><dd><dl class="simple">
<dt>coefficients and components: as defined by precip_convective in &amp;ModelSpecification</dt><dd><p>(main parent is first element of list)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>TOT_SNOW  Total precipitation in snow;</dt><dd><dl class="simple">
<dt>TOT_SNOW = linear combination of components</dt><dd><dl class="simple">
<dt>coefficients and components: as defined by precip_snow in &amp;ModelSpecification</dt><dd><p>(main parent is first element of list)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>TOT_RAIN  Total precipitation in rain;</dt><dd><dl class="simple">
<dt>TOT_RAIN = linear combination of components</dt><dd><dl class="simple">
<dt>coefficients and components: as defined by precip_rain in &amp;ModelSpecification</dt><dd><p>(main parent is first element of list)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>CONV_PERCENT Percentage of total precipitation which are convective;</dt><dd><dl>
<dt>CONV_PERCENT = 100 * (linear combination of TOT_CON components/TOT_PREC)</dt><dd><dl class="simple">
<dt>coefficients and components for TOT_CON:</dt><dd><p>as defined by precip_convective in &amp;ModelSpecification
(main parent is first element of list)</p>
</dd>
</dl>
<p>TOT_PREC:</p>
</dd>
</dl>
</dd>
<dt>SNOW_PERCENT Percentage of total precipitation in snow [%];</dt><dd><dl>
<dt>SNOW_PERCENT = 100 * (linear combination of TOT_SNOW components/TOT_PREC)</dt><dd><dl class="simple">
<dt>coefficients and components for TOT_SNOW:</dt><dd><p>as defined by precip_snow in &amp;ModelSpecification
(main parent is first element of list)</p>
</dd>
</dl>
<p>TOT_PREC:</p>
</dd>
</dl>
</dd>
<dt>MCONV     horizontal moisture flux convergence on model surface [s-1]</dt><dd><dl class="simple">
<dt>MCONV(QV,U,V,W,HEIGHT)</dt><dd><dl class="simple">
<dt>QV<span class="classifier">(in [kg kg-1], on mass point grid)</span></dt><dd><p>U : (in [m/s], on k-surface, in native ref. system, staggered)
V : (in [m/s], on k-surface, in native ref. system, staggered)
W : (in [m/s])</p>
</dd>
</dl>
</dd>
</dl>
<p>HEIGHT or HHL : (in [m], on model half levels)
When computing MCONV on level k, all listed fields must be available
on level k, W and HEIGHT must also be available on level k+1, QV, U and V must
be available on at least one adjacent level (left or right derivative in k
is applied when k+1 or k-1 level is missing)
This algorithm requires height based vertical coordinates.</p>
</dd>
</dl>
</section>
<section id="turbulence-variables">
<h3>Turbulence variables<a class="headerlink" href="#turbulence-variables" title="Permalink to this heading">#</a></h3>
<dl>
<dt>BRN       Bulk Richardson number (dimensionless quantity)</dt><dd><p>parent fields (T,P,QV) have to be available on all levels between
the target level and the first level above surface
BRN = pc_g * (HEIGHT(target) - HSURF) *                           &amp;</p>
<blockquote>
<div><blockquote>
<div><p>(THETA_V(target) - THETA_V(bottom)) /                    &amp;
(THETA_V_avg * (U(target)**2 + V(target)**2)) ,</p>
</div></blockquote>
<p>where pc_g (acceleration due to gravity),
THETA_V_avg (average of THETA_V between target and bottom levels)</p>
</div></blockquote>
<dl>
<dt>Note: to optimize the integral computing THETA_V_avg, it is</dt><dd><p>suggested to explicitely specify the list of produced levels
(levmin=…, levmax=…). This has for consequence to sort
the processing order according to this list.</p>
<blockquote>
<div><blockquote>
<div><p>T :  (in [K])
P :  (in [Pa])</p>
</div></blockquote>
<p>QV :
HSURF :  (in [m])</p>
</div></blockquote>
<dl class="simple">
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><p>U :  (in [m/s])
V :  (in [m/s])</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>RI        Gradient Richardson number (dimensionless quantity)</dt><dd><p>RI = pc_g * (dTHETA/dz) / (THETA * WSHEAR**2)
where pc_g (acceleration due to gravity)</p>
<blockquote>
<div><p>THETA : (in [K])
WSHEAR : (in [1/s])</p>
</div></blockquote>
<p>This algorithm is only supported for the COSMO model. (CHECK THIS)</p>
</dd>
<dt>HPBL      Height of the Planetary Boundary Layer (in [m])</dt><dd><p>HPBL is the height of the level above the surface where the
BRN value grows above the critical value (0.22)
BRN has to be available on all levels between the surface and
5000 m above surface level</p>
<blockquote>
<div><blockquote>
<div><p>BRN :
HSURF : (in [m])</p>
</div></blockquote>
<p>HEIGHT or HHL : (in [m], on model full levels)</p>
</div></blockquote>
</dd>
<dt>CAT_DVT   Divergence trend term (in [1/s**2])</dt><dd><p>CAT_DVT = C * WDIV_trend
where
C  (scaling factor &gt; 0.0, dimensionless quantity, see out_mode_dvt_scale)
For details on the choice of C see F. Binder, 2013 (ETHZ Master Thesis)
WDIV_trend (trend of divergence of horizontal wind, i.e.,</p>
<blockquote>
<div><blockquote>
<div><p>(WDIV(t) - WDIV(t’)) / (t - t’))</p>
</div></blockquote>
<p>WDIV : toper = delta (in [1/s], factor 1/(t-t’) is included in C)</p>
</div></blockquote>
<p>This algorithm is only supported for the COSMO model.</p>
</dd>
<dt>CAT_TI1   Ellrod and Knapp turbulence index 1 (in [1/s**2])</dt><dd><dl class="simple">
<dt>CAT_TI1 = WSHEAR * WDEF_H</dt><dd><p>WSHEAR : (in [1/s])
WDEF_H : (in [1/s])</p>
</dd>
</dl>
</dd>
<dt>CAT_TI2   Ellrod and Knapp turbulence index 2 (in [1/s**2])</dt><dd><dl class="simple">
<dt>CAT_TI2 = WSHEAR * (WDEF_H - WDIV)</dt><dd><p>WSHEAR : (in [1/s])
WDEF_H : (in [1/s])
WDIV : (in [1/s])</p>
</dd>
</dl>
</dd>
<dt>CAT_DTI   Divergence modified turbulence index (in [1/s**2])</dt><dd><dl class="simple">
<dt>CAT_DTI = CAT_TI1 + CAT_DVT</dt><dd><p>CAT_TI1 : (in [1/s**2])
CAT_DVT : (in [1/s**2])</p>
</dd>
</dl>
</dd>
<dt>EDP       Eddy dissipation parameter for aviation meteorology (in [m**(2/3) s**(-1)]</dt><dd><p>ICON model only
Calculate eddy dissipation parameter, based on the direct usage of the
prognostic turbulent kinetic energy, using a MY level 2.5 approach and
new scale interacting terms:
EDP = [(2*TKE)**1/2]/(len_scale*A)**1/3 + (DTKE_CON)**1/3 + (B*DTKE_HSH)**1/3</p>
<blockquote>
<div><p>len_scale : formulation according to MESINGER 1993
A : dissipation-constant (16.6)
B : scaling factor (1.0)</p>
</div></blockquote>
<p>For a detailed description see Raschendorfer, Barleben
(2014, PROMET Jahr.39,Nr.2,23-35)</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>TKE :</p>
</div></blockquote>
<p>DTKE_CON :
DTKE_HSH :</p>
</div></blockquote>
<p>HEIGHT or HHL :  (in [m], on model half levels)</p>
</div></blockquote>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Turbulence</span><span class="p">:</span> <span class="s2">&quot;Direct&quot;</span> <span class="n">approach</span>
</pre></div>
</div>
<p>The following operators are limited to the COSMO model.
Meaningful results are only produced when associated with a TKE
formulation following Mellor and Yamada (1982) level 2.5.</p>
<dl>
<dt>SIGMAX    Velocity fluctuation along the model x-axis (in [m/s])</dt><dd><p>Based on the direct usage of prognostic Turbulent Kinetic Energy,
using a Mellor and Yamada (1982) level 2.5 approach
For detailed description see Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>TKE :</dt><dd><p>T : (in [K])
P : (in [Pa])
QV :</p>
</dd>
</dl>
<p>HSURF : (in [m])</p>
</div></blockquote>
<dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><p>U : (in [m/s])
V : (in [m/s])</p>
</div></blockquote>
<p>TKVM :
TKVH :</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>SIGMAY    Velocity fluctuation along the model y-axis (in [m/s])</dt><dd><p>Based on the direct usage of prognostic Turbulent Kinetic Energy,
using a Mellor and Yamada (1982) level 2.5 approach
For detailed description see Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>TKE :</dt><dd><p>T : (in [K])
P : (in [Pa])
QV :</p>
</dd>
</dl>
<p>HSURF : (in [m])</p>
</div></blockquote>
<dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><p>U : (in [m/s])
V : (in [m/s])</p>
</div></blockquote>
<p>TKVM :
TKVH :</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>SIGMAZ    Vertical velocity fluctuation (in [m/s])</dt><dd><p>Based on the direct usage of prognostic Turbulent Kinetic Energy,
using a Mellor and Yamada (1982) level 2.5 approach
For detailed description see Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>TKE :</dt><dd><p>T : (in [K])
P : (in [Pa])
QV :</p>
</dd>
</dl>
<p>HSURF : (in [m])</p>
</div></blockquote>
<dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><p>U : (in [m/s])
V : (in [m/s])</p>
</div></blockquote>
<p>TKVM :
TKVH :</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>LAGTIMEX  Lagrangian timescale along the model x-axis (in [s])</dt><dd><p>Based on the direct usage of prognostic Turbulent Kinetic Energy,
using a Mellor and Yamada (1982) level 2.5 approach
For detailed description see Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>TKE :</dt><dd><p>T : (in [K])
P : (in [Pa])
QV :</p>
</dd>
</dl>
<p>HSURF : (in [m])</p>
</div></blockquote>
<dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><p>U : (in [m/s])
V : (in [m/s])</p>
</div></blockquote>
<p>TKVM :
TKVH :</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>LAGTIMEY  Lagrangian timescale along the model y-axis (in [s])</dt><dd><p>Based on the direct usage of prognostic Turbulent Kinetic Energy,
using a Mellor and Yamada (1982) level 2.5 approach
For detailed description see Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>TKE :</dt><dd><p>T : (in [K])
P : (in [Pa])
QV :</p>
</dd>
</dl>
<p>HSURF : (in [m])</p>
</div></blockquote>
<dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><p>U : (in [m/s])
V : (in [m/s])</p>
</div></blockquote>
<p>TKVM :
TKVH :</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>LAGTIMEZ  Lagrangian timescale for vertical direction (in [s])</dt><dd><p>Based on the direct usage of prognostic Turbulent Kinetic Energy,
using a Mellor and Yamada (1982) level 2.5 approach
For detailed description see Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>TKE :</dt><dd><p>T : (in [K])
P : (in [Pa])
QV :</p>
</dd>
</dl>
<p>HSURF : (in [m])</p>
</div></blockquote>
<dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><p>U : (in [m/s])
V : (in [m/s])</p>
</div></blockquote>
<p>TKVM :
TKVH :</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Turbulence</span><span class="p">:</span> <span class="n">Similarity</span> <span class="n">approach</span>
</pre></div>
</div>
<p>Above the PBL top all values are set to undefined.
Neutral conditions and surface layer are ignored.</p>
<dl>
<dt>SIGMAU    Along-wind velocity fluctuation (in [m/s])</dt><dd><p>Based on similarity theory considerations
For detailed description see Hanna (1982) and Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><blockquote>
<div><p>T : (in [K])
P : (in [Pa])
QV :</p>
</div></blockquote>
<p>HSURF : (in [m])</p>
</div></blockquote>
<p>AUMFL_S : (in [Pa]), toper = tdelta
AVMFL_S : (in [Pa]), toper = tdelta
ASHFL_S : (in [W/m2]), toper = tdelta</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>SIGMAV    Cross-wind velocity fluctuation (in [m/s])</dt><dd><p>Based on similarity theory considerations
For detailed description see Hanna (1982) and Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><blockquote>
<div><p>T : (in [K])
P : (in [Pa])
QV :</p>
</div></blockquote>
<p>HSURF : (in [m])</p>
</div></blockquote>
<p>AUMFL_S : (in [Pa]), toper = tdelta
AVMFL_S : (in [Pa]), toper = tdelta
ASHFL_S : (in [W/m2]), toper = tdelta</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>SIGMAW    Vertical velocity fluctuation (in [m/s])</dt><dd><p>Based on similarity theory considerations
For detailed description see Hanna (1982) and Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><blockquote>
<div><p>T : (in [K])
P : (in [Pa])
QV :</p>
</div></blockquote>
<p>HSURF : (in [m])</p>
</div></blockquote>
<p>AUMFL_S : (in [Pa]), toper = tdelta
AVMFL_S : (in [Pa]), toper = tdelta
ASHFL_S : (in [W/m2]), toper = tdelta</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>LAGTIMEU  Along-wind Lagrangian timescale (in [s])</dt><dd><p>Based on similarity theory considerations
For detailed description see Hanna (1982) and Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><blockquote>
<div><p>T : (in [K])
P : (in [Pa])
QV :</p>
</div></blockquote>
<p>HSURF : (in [m])</p>
</div></blockquote>
<p>AUMFL_S : (in [Pa]), toper = tdelta
AVMFL_S : (in [Pa]), toper = tdelta
ASHFL_S : (in [W/m2]), toper = tdelta</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>LAGTIMEV  Cross-wind Lagrangian timescale (in [s])</dt><dd><p>Based on similarity theory considerations
For detailed description see Hanna (1982) and Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><blockquote>
<div><p>T : (in [K])
P : (in [Pa])
QV :</p>
</div></blockquote>
<p>HSURF : (in [m])</p>
</div></blockquote>
<p>AUMFL_S : (in [Pa]), toper = tdelta
AVMFL_S : (in [Pa]), toper = tdelta
ASHFL_S : (in [W/m2]), toper = tdelta</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>LAGTIMEW  Lagrangian timescale for vertical direction (in [s])</dt><dd><p>Based on similarity theory considerations
For detailed description see Hanna (1982) and Szintai, 2010 (EPFL Thesis)</p>
<blockquote>
<div><dl>
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><blockquote>
<div><blockquote>
<div><p>T : (in [K])
P : (in [Pa])
QV :</p>
</div></blockquote>
<p>HSURF : (in [m])</p>
</div></blockquote>
<p>AUMFL_S : (in [Pa]), toper = tdelta
AVMFL_S : (in [Pa]), toper = tdelta
ASHFL_S : (in [W/m2]), toper = tdelta</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</section>
<section id="indices">
<h3>indices<a class="headerlink" href="#indices" title="Permalink to this heading">#</a></h3>
<dl>
<dt>CAPE_MU   convective available potential energy. Several parcels are lifted from</dt><dd><p>different levels. Returned is the largest CAPE value achieved by the
most unstable parcel ascent.
Required parent fields:
CAPE_ML(T,P,QV,HEIGHT) = [for details look at lm_pp_utilities]</p>
<blockquote>
<div><blockquote>
<div><p>T : (in [K])     [all levels required]
P : (in [Pa])    [all levels required]
QV : (in [kg/kg]) [all levels required]</p>
</div></blockquote>
<dl class="simple">
<dt>HEIGHT or HHL<span class="classifier">(in [m], on model half levels)</span></dt><dd><p>HSURF : (in [m])</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>CIN_MU    convective inhibition for the ascent of the most unstable parcel.</dt><dd><p>Requires the same parent fields as CAPE_MU.</p>
</dd>
<dt>CAPE_ML   convective available potential energy, achieved by a parcel starting</dt><dd><p>from the computed mixing layer.
Requires the same parent fields as CAPE_MU.</p>
</dd>
<dt>CIN_ML    convective inhibition for the ascent of a parcel starting at the mixing layer.</dt><dd><p>Requires the same parent fields as CAPE_MU.</p>
</dd>
<dt>LCL_ML    mixed layer lifting condensation level above ground.</dt><dd><p>Requires the same parent fields as CAPE_MU.</p>
</dd>
<dt>LFC_ML    mixed layer level of free convection above ground.</dt><dd><p>Requires the same parent fields as CAPE_MU.</p>
</dd>
<dt>SI        Showalter index. A parcel starting at 850hPa is lifted along dry adiabatic</dt><dd><p>till it has reached dew point temperature; it is then further lifted
along moist adiabatic up to 500hPa. The temperature difference between
the parcel and the environment is returned.
Requires the same parent fields as CAPE_MU.</p>
</dd>
<dt>SLI       surface lifted index. Similar to SI, except that the parcel start from</dt><dd><p>the surface.
Requires the same parent fields as CAPE_MU.</p>
</dd>
<dt>KINDEX    K index</dt><dd><dl class="simple">
<dt>KINDEX(T,P,QV) = (T850 - T500 + TD850 - DTD700)</dt><dd><p>T : (in [K])
P : (in [Pa])</p>
</dd>
</dl>
<p>QV :</p>
</dd>
<dt>KOINDEX   KO index (with modified levels: 850,760,625,450)</dt><dd><dl class="simple">
<dt>KOINDEX(T,P,QV) = 0.5 * (THETAE450 + THETAE625 - THETAE760 - THETAE850)</dt><dd><p>T : (in [K])
P : (in [Pa])</p>
</dd>
</dl>
<p>QV :</p>
</dd>
<dt>TTINDEX   Total-Totals index (TT-index)</dt><dd><dl class="simple">
<dt>The index is based on the temperature, pressure and humidity on</dt><dd><p>850hPa and on the temperature on 500hPa. The values are taken from
nearest model level</p>
</dd>
<dt>TT(T,P,QV) = 2*(T850-T500) - (T850-273) + (TD850(P,QV)-273)</dt><dd><p>T : (in [K])
P : (in [Pa])</p>
</dd>
</dl>
<p>QV :</p>
</dd>
<dt>SWEAT     Severe weather threat index</dt><dd><dl>
<dt>An index based on temperature, pressure, humidity and horizontal wind</dt><dd><p>components at 850hPa and 500hPa. Values are taken from the closest
model levels. The needed values are dew point on 850hPa (TD850), TT-
index (TT), horizontal wind velocity on 850hPa and 500hPa (FF850,
FF500) and sinus of the angle between the wind vectors on 500hPa and
850hPa (s).</p>
</dd>
<dt>SWEAT(T,P,QV,U,V) = 12*(TD850(P,QV)-273) + 20*(TT(T,P,QV)-49) +</dt><dd><blockquote>
<div><p>2*FF850(U,V)+FF500(U,V)+125*(s+0.2)</p>
</div></blockquote>
<p>T : (in [K])
P : (in [Pa])</p>
</dd>
<dt>QV :</dt><dd><p>U : (in [m/s])
V : (in [m/s])</p>
</dd>
</dl>
</dd>
<dt>DCI       deep convection index (DCI)</dt><dd><blockquote>
<div><blockquote>
<div><p>The temperature, pressure and humidity fields are needed to compute
DCI. T850 is the temperature of the model level closest to 850hPa
and TD850 the dew point temperature on 850hPa. SLI denotes the
surface lifted index</p>
</div></blockquote>
<dl class="simple">
<dt>DCI(T,P,QV) = (T850-273) + (TD850(P,QV)-273) - SLI</dt><dd><p>T : (in [K])
P : (in [Pa])
QV :</p>
</dd>
</dl>
</div></blockquote>
<p>HEIGHT or HHL : (in [m], on model half levels)</p>
</dd>
<dt>ADEDO2    Adedokun 2 index: Lowering a parcel from 500hPa to surface moist</dt><dd><blockquote>
<div><p>adiabatically and comparing the wet bulb temperature
of this parcel (THETAW_500S) with the wet bulb
temperature at surface (THETAW_S)</p>
</div></blockquote>
<dl class="simple">
<dt>ADEDO2(T,P,QV) = THETAW_S(T,P,QV) - THETAW_500S(T,P,QV)</dt><dd><p>T : (in [K])
P : (in [Pa])</p>
</dd>
</dl>
<p>QV :</p>
</dd>
</dl>
</section>
<section id="synthetic-satellite-images">
<h3>Synthetic satellite images<a class="headerlink" href="#synthetic-satellite-images" title="Permalink to this heading">#</a></h3>
<p>Calculate synthetic satellite forward observation operator using
the release 11 of the RTTOV library.</p>
<p>Three different treatments of clouds are supported, as defined by
out_mode_rttov_cloud:</p>
<blockquote>
<div><p>no cloud (only clear sky product can be computed),
simple clouds (only cloud cover and cloud top information is used),
complex clouds (cloud types and cloud profiles information is used)</p>
</div></blockquote>
<p>The information on the satellite, the instrument and the channel to
consider is taken from the active dictionary (rttovId, rttovChan),
on the basis of the field name.</p>
<p>The RTTOV coefficient file for the chosen satellite and instrument must
be available at the place specified by user_settings%rttov_coefs_path
(the name of the coefficient file is built on the basis of rttovId);
furthermore, when the complex cloud treatment is active, the IR cloud
scattering coefficient file must also be available.</p>
<p>The channels represented in the cloud coefficient file must be the same
as the channels represented in the RTTOV coefficient file.</p>
<dl>
<dt>The following auxiliary fields are used as parents:</dt><dd><dl class="simple">
<dt>RTTOV_STYPE: surface type field: 0:land, 1:sea, 2:sea-ice ;</dt><dd><p>(COSMO with H_ICE) SOILTYP=9 &amp;&amp; H_ICE&gt;0.01 =&gt; RTTOV_STYPE=2</p>
</dd>
<dt>RTTOV_WTYPE: water type field: 0:fresh water, 1:ocean water ;</dt><dd><p>(COSMO with LAKE_DP) SOILTYP&gt;=9 &amp;&amp; DEPTH_LK=0 =&gt; RTTOV_WTYPE=1</p>
</dd>
<dt>RTTOV_FRSNOW: snow fraction field: between 0 and 1 ;</dt><dd><p>(COSMO) MIN(1.0, W_SNOW/cf_snow), with cf_snow = 0.015</p>
</dd>
</dl>
<p>… for simple clouds treatment
RTTOV_TOPCLOUD: cloud top in hPa
RTTOV_FRCLOUD_TOT: total cloud fraction, between 0 and 1
… for complex clouds treatment
RTTOV_FRCLOUD: cloud fraction profile: between 0 and 1 ;
RTTOV_CLOUD_1: cloud content profile, in g/m^3, for cloud category ‘stratus continental’
RTTOV_CLOUD_3: cloud content profile, in g/m^3, for cloud category ‘cumulus continental’
RTTOV_CLOUD_6: cloud content profile, in g/m^3, for cloud category ‘cirrus’</p>
</dd>
</dl>
<p>The release 11.2 of the RTTOV library is required
(see <a class="reference external" href="https://nwpsaf.eu/deliverables/rtm/">https://nwpsaf.eu/deliverables/rtm/</a> for RTTOV documentation).</p>
<p>Some optimization of the complex clouds forward operator is introduced
by ignoring any cloud columns with weights smaller than 1.E-4; a speedup
of about 30% is achieved at the cost of a non significant degradation
of the product quality (NWP SAF advice, see ticket id “gKqpbxFWT”).</p>
<p>The following products can be computed:</p>
<p>(1) MSG cloudy brightness temperature, out_mode_rttov_cloud=’complex’
SYNMSG_BT_CL_IR10.8, SYNMSG_BT_CL_IR12.1, SYNMSG_BT_CL_IR13.4,
SYNMSG_BT_CL_IR3.9 , SYNMSG_BT_CL_IR8.7 , SYNMSG_BT_CL_IR9.7 ,
SYNMSG_BT_CL_WV6.2 , SYNMSG_BT_CL_WV7.3</p>
<blockquote>
<div><p>P, T, QV: on model half levels
U_10M, V_10M, T_2M, PS, QV_2M, T_G, HSURF:
RTTOV_STYPE, RTTOV_WTYPE, RTTOV_FRSNOW:
RTTOV_FRCLOUD, RTTOV_CLOUD_1, RTTOV_CLOUD_3, RTTOV_CLOUD_6:
on model full levels; P, T and QV must be available on
all associated model half levels</p>
</div></blockquote>
<p>(2) MSG cloudy brightness temperature, out_mode_rttov_cloud=’simple’
SYNMSG_BT_CL_IR10.8, SYNMSG_BT_CL_IR12.1, SYNMSG_BT_CL_IR13.4,
SYNMSG_BT_CL_IR3.9 , SYNMSG_BT_CL_IR8.7 , SYNMSG_BT_CL_IR9.7 ,
SYNMSG_BT_CL_WV6.2 , SYNMSG_BT_CL_WV7.3</p>
<blockquote>
<div><p>P, T, QV: on model full levels
U_10M, V_10M, T_2M, PS, QV_2M, T_G, HSURF:
RTTOV_STYPE, RTTOV_WTYPE, RTTOV_FRSNOW:
RTTOV_TOPCLOUD, RTTOV_FRCLOUD_TOT:</p>
</div></blockquote>
<p>(3) MSG clear sky brightness temperature
SYNMSG_BT_CS_IR10.8, SYNMSG_BT_CS_IR12.1, SYNMSG_BT_CS_IR13.4,
SYNMSG_BT_CS_IR3.9 , SYNMSG_BT_CS_IR8.7 , SYNMSG_BT_CS_IR9.7 ,
SYNMSG_BT_CS_WV6.2 , SYNMSG_BT_CS_WV7.3</p>
<blockquote>
<div><p>P, T, QV: on model full levels
U_10M, V_10M, T_2M, PS, QV_2M, T_G, HSURF:
RTTOV_STYPE, RTTOV_WTYPE, RTTOV_FRSNOW:</p>
</div></blockquote>
<p>Explanantion of MSG SEVIRI channels:
rttovChan    lambda           Useful for                         Peak
(coef file)  (micrometers)
1            IR 3.9           Surface, clouds, wind fields       surface
2            WV 6.2           Water vapor, high level clouds,    300 hPa
3            WV 7.3           Water vapor                        500 hPa
4            IR 8.7           Surface, clouds                    surface
5            IR 9.7           Ozone                              surface + 50hPa
6            IR 10.8          Surface, clouds, wind fields       surface
7            IR 12.0          Surface, clouds, wind fields       surface
8            IR 13.4          Cirrus cloud height                850 hPa</p>
</section>
<section id="statistical-post-processing">
<h3>Statistical post-processing<a class="headerlink" href="#statistical-post-processing" title="Permalink to this heading">#</a></h3>
<dl>
<dt>CN_TSTORM (normalized) probability for a thunderstrom to occur [%].</dt><dd><p>Algorithm is derived from AdaBoost classifier, and the values
are obtained by using the information in the corresponding
adaboost_coefs file (see 6.6 below).
The set of parent fields is described by the list of features
in this latter file. Two kind of classifier can be applied,
Threshold Classifier and Decision Tree Classifier, and the
one applied is also defined in this file.
CN_TSTORM = CN_TSTORM(INPUT)</p>
<blockquote>
<div><dl class="simple">
<dt>INPUT:      set of fields as defined by the list</dt><dd><p>of ‘standard’ features in adaboost_coefs
file (‘standard’ means not considering
one of DAYOFYEAR, TIME, HEIGHT)</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>C_TSTORM  as CN_TSTORM, but value is the raw classifier output.</dt><dd><p>Its range is between 0 (no event) and 1 (event occurs).</p>
</dd>
</dl>
</section>
<section id="generic-operators">
<h3>Generic operators<a class="headerlink" href="#generic-operators" title="Permalink to this heading">#</a></h3>
<p>Generic operators are characterized by a main parent which is arbitrary,
and whose identity is set in the namelist.</p>
<dl>
<dt>AD2D_TRACER   horizontal advection of TRACER on model surface.</dt><dd><blockquote>
<div><dl>
<dt>AD2D_TRACER(tracer) = (u,v) * GRADIENT(tracer)</dt><dd><blockquote>
<div><dl class="simple">
<dt>TRACER<span class="classifier">any scalar field</span></dt><dd><p>U : (in [m/s], on k-surface, in native ref. system, staggered)
V : (in [m/s], on k-surface, in native ref. system, staggered)</p>
</dd>
</dl>
</div></blockquote>
<p>HEIGHT or HHL : (in [m], on model half levels)</p>
</dd>
</dl>
</div></blockquote>
<p>TRACER is a generic field identity, which is declared in the namelist
by using “new_field_id” (e.g. to use THETAE as tracer, one should set
&amp;Process tmp1_field =”THETAE”, new_field_id=”TRACER,K” / ).
When computing AD2D_TRACER on level k, all listed fields must be available
on level k, HEIGHT must also be available on level k+1, TRACER must be
available on at least one adjacent level (left or right derivative in k
is applied when k+1 or k-1 level is missing).
It is compulsory to use “set_units” or “new_field_id” to manually set
the field units of the resulting field.
This algorithm requires height based vertical coordinates.</p>
</dd>
</dl>
</section>
</section>
<section id="named-operators">
<h2>Named operators<a class="headerlink" href="#named-operators" title="Permalink to this heading">#</a></h2>
<p>(Activated by setting ‘use_operator’ and ‘use_tag’)</p>
<dl class="simple">
<dt>operator  operator description</dt><dd><p>list of parent fields (first in the list is the main parent)</p>
</dd>
</dl>
<section id="id21">
<h3>constant fields (produced in INCORE)<a class="headerlink" href="#id21" title="Permalink to this heading">#</a></h3>
<dl>
<dt>qvsat   Specific water vapor content at saturation over water [kg/kg]</dt><dd><p>qvsat = qvsat(temperature, pressure)
Implemented for one of the two following cases:
a) parents in {T_2M, PS}</p>
<blockquote>
<div><p>T_2M:  (in [K])
PS:    (in [Pa])</p>
</div></blockquote>
<ol class="loweralpha simple" start="2">
<li><dl class="simple">
<dt>parents in {T, P}</dt><dd><p>T:     (in [K])
P:     (in [Pa])</p>
</dd>
</dl>
</li>
</ol>
<p>In case a), the surface pressure is reduced hydrostatically to
a 2 meter pressure, using constant temperature T_2M.</p>
</dd>
</dl>
</section>
</section>
<section id="postprocessing-operators">
<h2>Postprocessing operators<a class="headerlink" href="#postprocessing-operators" title="Permalink to this heading">#</a></h2>
<p>None available (but see also README.user.locale)</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="support.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Description of support files</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="control/process.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title"><code class="xref py py-mod docutils literal notranslate"><span class="pre">&amp;Process</span></code></div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Jean-Marie Bettems, Tierry Hörmann
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Operators to compute new fields</a><ul>
<li><a class="reference internal" href="#meteorological-operators">Meteorological operators</a><ul>
<li><a class="reference internal" href="#constant-fields-produced-in-incore">constant fields (produced in INCORE)</a></li>
<li><a class="reference internal" href="#soil-and-surface">soil and surface</a></li>
<li><a class="reference internal" href="#mass-field">mass field</a></li>
<li><a class="reference internal" href="#wind">wind</a></li>
<li><a class="reference internal" href="#quasi-geostrophic-approximation">quasi-geostrophic approximation</a></li>
<li><a class="reference internal" href="#radiation">radiation</a></li>
<li><a class="reference internal" href="#thermodynamic-quantities">thermodynamic quantities</a></li>
<li><a class="reference internal" href="#precipitation-and-moisture-transport">precipitation and moisture transport</a></li>
<li><a class="reference internal" href="#turbulence-variables">Turbulence variables</a></li>
<li><a class="reference internal" href="#indices">indices</a></li>
<li><a class="reference internal" href="#synthetic-satellite-images">Synthetic satellite images</a></li>
<li><a class="reference internal" href="#statistical-post-processing">Statistical post-processing</a></li>
<li><a class="reference internal" href="#generic-operators">Generic operators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#named-operators">Named operators</a><ul>
<li><a class="reference internal" href="#id21">constant fields (produced in INCORE)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#postprocessing-operators">Postprocessing operators</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/scripts/furo.js"></script>
    </body>
</html>